"use client";

import { useState, useCallback } from "react";
import Link from "next/link";
import { UploadPanel } from "@/components/UploadPanel";
import { ExtractionCanvas } from "@/components/ExtractionCanvas";
import { ResultsPanel } from "@/components/ResultsPanel";
import { Charts } from "@/components/Charts";
import { FundData, ExtractEvent, ExtractionStatus } from "@/lib/types";
import { generateUUID } from "@/lib/utils";
import { MessageSquare, FileText, ArrowRight } from "lucide-react";

export default function FundExtractionPage() {
  // State management
  const [uploadedFile, setUploadedFile] = useState<File | null>(null);
  const [uploadedFiles, setUploadedFiles] = useState<File[]>([]);
  const [filePath, setFilePath] = useState<string | null>(null);
  const [filePaths, setFilePaths] = useState<string[]>([]);
  const [csvSessionId, setCsvSessionId] = useState<string | null>(null);
  const [csvSessionIds, setCsvSessionIds] = useState<Record<string, string>>({});
  const [extractionStatus, setExtractionStatus] = useState<ExtractionStatus>("idle");
  const [extractionProgress, setExtractionProgress] = useState<number>(0);
  const [extractionStage, setExtractionStage] = useState<string>("");
  const [extractionLogs, setExtractionLogs] = useState<string[]>([]);
  const [fundData, setFundData] = useState<FundData[]>([]);
  const [selectedFund, setSelectedFund] = useState<FundData | null>(null);
  const [isExtracting, setIsExtracting] = useState<boolean>(false);
  const [activeTab, setActiveTab] = useState<"results" | "charts">("results");

  // Handle file upload - single or multiple
  const handleFileUpload = useCallback(async (files: File | File[]) => {
    const fileArray = Array.isArray(files) ? files : [files];
    
    if (fileArray.length === 1) {
      setUploadedFile(fileArray[0]);
      setUploadedFiles([]);
    } else {
      setUploadedFile(null);
      setUploadedFiles(fileArray);
    }
    
    setExtractionStatus("uploading");
    setExtractionLogs(prev => [...prev, `üì§ Uploading ${fileArray.length} file(s)...`]);

    try {
      const uploadedPaths: string[] = [];
      const newCsvSessionIds: Record<string, string> = {};
      
      for (const file of fileArray) {
        const fileExtension = file.name.split('.').pop()?.toLowerCase();
        const isCSV = ['csv', 'xlsx', 'xls'].includes(fileExtension || '');
        
        if (isCSV) {
          // Use onboarding system for CSV/Excel files
          setExtractionLogs(prev => [...prev, `üîÑ Creating session for ${file.name}...`]);
          
          // Create onboarding session
          const sessionResponse = await fetch("/api/onboarding/session/create", {
            method: "POST",
          });
          
          if (!sessionResponse.ok) {
            throw new Error(`Failed to create session for ${file.name}`);
          }
          
          const sessionData = await sessionResponse.json();
          
          // Upload file to onboarding system
          const formData = new FormData();
          formData.append("file", file);
          
          const uploadResponse = await fetch(`/api/onboarding/upload?session_id=${sessionData.session_id}`, {
            method: "POST",
            body: formData,
          });
          
          if (!uploadResponse.ok) {
            let errorMessage = `Upload failed for ${file.name}: ${uploadResponse.statusText}`;
            try {
              const errorData = await uploadResponse.json();
              if (errorData.detail) {
                errorMessage += ` - ${errorData.detail}`;
              }
            } catch {
              // Use statusText only if JSON parsing fails
            }
            throw new Error(errorMessage);
          }
          
          const uploadResult = await uploadResponse.json();
          uploadedPaths.push(uploadResult.file_path);
          newCsvSessionIds[uploadResult.file_path] = sessionData.session_id;
          
        } else {
          // Use regular upload for PDFs
          const formData = new FormData();
          formData.append("file", file);

          const response = await fetch("/api/upload", {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            let errorMessage = `Upload failed: ${response.statusText}`;
            const responseClone = response.clone();
            try {
              const errorData = await response.json();
              if (errorData.detail) {
                errorMessage += ` - ${errorData.detail}`;
              }
            } catch {
              try {
                const errorText = await responseClone.text();
                if (errorText) {
                  errorMessage += ` - ${errorText}`;
                }
              } catch {
                // If both JSON and text parsing fail, use statusText only
              }
            }
            throw new Error(errorMessage);
          }

          const result = await response.json();
          uploadedPaths.push(result.file_path);
        }
        
        setExtractionLogs(prev => [...prev, `‚úÖ ${file.name} uploaded successfully`]);
      }
      
      // Update session IDs state
      if (Object.keys(newCsvSessionIds).length > 0) {
        if (uploadedPaths.length === 1) {
          setCsvSessionId(Object.values(newCsvSessionIds)[0]);
        }
        setCsvSessionIds(prev => ({ ...prev, ...newCsvSessionIds }));
      }
      
      if (uploadedPaths.length === 1) {
        setFilePath(uploadedPaths[0]);
        setFilePaths([]);
      } else {
        setFilePath(null);
        setFilePaths(uploadedPaths);
      }
      
      setExtractionStatus("uploaded");
      setExtractionLogs(prev => [...prev, `‚úÖ All files uploaded successfully`]);
      
      // Automatically start extraction after successful upload
      setTimeout(() => {
        if (window.handleStartExtractionRef) {
          window.handleStartExtractionRef();
        }
      }, 500); // Small delay to ensure UI updates are visible

    } catch (error) {
      console.error("Upload error:", error);
      setExtractionStatus("error");
      setExtractionLogs(prev => [...prev, `‚ùå Upload failed: ${error}`]);
    }
  }, []);

  // Core extraction logic that can be called from multiple places
  const startExtraction = async (pathToProcess: string) => {
    // Determine file type from path
    const fileExtension = pathToProcess.split('.').pop()?.toLowerCase();
    const isCSV = ['csv', 'xlsx', 'xls'].includes(fileExtension || '');
    
    let endpoint, body;
    
    if (isCSV) {
      // Use onboarding system for CSV/Excel files with existing session
      endpoint = "/api/onboarding/process";
      
      // Get the session ID for this file
      const sessionId = filePath === pathToProcess ? csvSessionId : csvSessionIds[pathToProcess];
      
      if (!sessionId) {
        throw new Error("No onboarding session found for this CSV file. Please re-upload the file.");
      }
      
      body = JSON.stringify({
        session_id: sessionId,
        action: "upload_file",
        data: {
          file_path: pathToProcess,
          file_type: fileExtension
        }
      });
    } else {
      // Use PDF extraction agent for PDFs
      endpoint = "/api/fund-extraction-agent";
      body = JSON.stringify({
        file_path: pathToProcess,
        message: "Extract fund data from this PDF",
        threadId: generateUUID(),
        messageId: generateUUID(),
      });
    }

    if (isCSV) {
      // For CSV files, send the process request first
      const response = await fetch(endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: body,
      });

      if (!response.ok) {
        let errorMessage = `Extraction failed: ${response.statusText}`;
        const responseClone = response.clone();
        try {
          const errorData = await response.json();
          if (errorData.detail) {
            errorMessage += ` - ${errorData.detail}`;
          }
        } catch {
          try {
            const errorText = await responseClone.text();
            if (errorText) {
              errorMessage += ` - ${errorText}`;
            }
          } catch {
            // If both JSON and text parsing fail, use statusText only
          }
        }
        throw new Error(errorMessage);
      }

      // Get the session ID for streaming
      const sessionId = filePath === pathToProcess ? csvSessionId : csvSessionIds[pathToProcess];
      
      // Now connect to the enhanced streaming endpoint for CSV
      const streamResponse = await fetch(`/api/onboarding/enhanced-stream/${sessionId}`);
      
      if (!streamResponse.ok) {
        throw new Error(`Failed to connect to stream: ${streamResponse.statusText}`);
      }

      const reader = streamResponse.body?.getReader();
      if (!reader) throw new Error("No reader available");

      setExtractionLogs(prev => [...prev, "üì° Connected to extraction stream..."]);

      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = new TextDecoder().decode(value);
          const lines = chunk.split('\n').filter(line => line.trim());

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const eventData = JSON.parse(line.slice(6));
                
                if (eventData.type === 'status_update') {
                  const status = eventData.data?.status || 'processing';
                  const stage = eventData.data?.stage || '';
                  const agent = eventData.data?.agent || '';
                  setExtractionLogs(prev => [...prev, `üîÑ ${agent}: ${stage} (${status})`]);
                } else if (eventData.type === 'data_processed') {
                  const portfolioItems = eventData.data?.portfolio_items || [];
                  setExtractionLogs(prev => [...prev, `‚úÖ Found ${portfolioItems.length} funds`]);
                  setFundData(portfolioItems.map((item: any) => ({
                    ticker: item.ticker,
                    name: item.name,
                    expense_ratio: item.expense_ratio,
                    category: item.morningstar_category,
                    asset_class: item.asset_class
                  })));
                } else if (eventData.type === 'chat_response') {
                  setExtractionLogs(prev => [...prev, `üí¨ ${eventData.data?.message}`]);
                }
              } catch (parseError) {
                console.warn("Failed to parse event data:", parseError);
              }
            }
          }
        }

        setExtractionStatus("completed");
        setExtractionProgress(100);
        setExtractionLogs(prev => [...prev, "üéâ Extraction completed successfully!"]);
      } finally {
        reader.releaseLock();
      }
    } else {
      // Handle PDF streaming (existing logic)
      const response = await fetch(endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: body,
      });

      if (!response.ok) {
        let errorMessage = `Extraction failed: ${response.statusText}`;
        // Handle error parsing like above
        throw new Error(errorMessage);
      }

      const reader = response.body?.getReader();
      if (!reader) throw new Error("No reader available");

      setExtractionLogs(prev => [...prev, "üì° Connected to extraction stream..."]);

      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = new TextDecoder().decode(value);
          const lines = chunk.split('\n').filter(line => line.trim());

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const eventData = JSON.parse(line.slice(6));
                
                if (eventData.type === 'status') {
                  const stage = eventData.data?.stage || 'Processing';
                  const progress = eventData.data?.progress || 0;
                  setExtractionStage(stage);
                  setExtractionProgress(progress);
                  setExtractionLogs(prev => [...prev, `üîÑ ${stage} (${progress}%)`]);
                } else if (eventData.type === 'fund_extracted') {
                  const fund = eventData.data;
                  setFundData(prev => [...prev, fund]);
                  setExtractionLogs(prev => [...prev, `‚úÖ Extracted: ${fund.name} (${fund.ticker})`]);
                } else if (eventData.type === 'results') {
                  setExtractionStatus("completed");
                  setExtractionProgress(100);
                  setExtractionLogs(prev => [...prev, "üéâ Extraction completed successfully!"]);
                }
              } catch (parseError) {
                console.warn("Failed to parse event data:", parseError);
              }
            }
          }
        }
      } finally {
        reader.releaseLock();
      }
    }
  };

  // Handle extraction start
  const handleStartExtraction = useCallback(async () => {
    if (!filePath && filePaths.length === 0) return;
    
    const pathToProcess = filePath || filePaths[0]; // For now, process first file

    setIsExtracting(true);
    setExtractionStatus("processing");
    setExtractionProgress(0);
    setExtractionLogs([]);
    setFundData([]);
    setSelectedFund(null);

    try {
      await startExtraction(pathToProcess);
    } catch (error) {
      console.error("Extraction error:", error);
      setExtractionStatus("error");
      setExtractionLogs(prev => [...prev, `‚ùå Extraction failed: ${error}`]);
    } finally {
      setIsExtracting(false);
    }
  }, [filePath, filePaths]);
      // Determine file type from path
      const fileExtension = pathToProcess.split('.').pop()?.toLowerCase();
      const isCSV = ['csv', 'xlsx', 'xls'].includes(fileExtension || '');
      
      let endpoint, body;
      
      if (isCSV) {
        // Use onboarding system for CSV/Excel files with existing session
        endpoint = "/api/onboarding/process";
        
        // Get the session ID for this file
        const sessionId = filePath ? csvSessionId : csvSessionIds[pathToProcess];
        
        if (!sessionId) {
          throw new Error("No onboarding session found for this CSV file. Please re-upload the file.");
        }
        
        body = JSON.stringify({
          session_id: sessionId,
          action: "upload_file",
          data: {
            file_path: pathToProcess,
            file_type: fileExtension
          }
        });
      } else {
        // Use PDF extraction agent for PDFs
        endpoint = "/api/fund-extraction-agent";
        body = JSON.stringify({
          file_path: pathToProcess,
          message: "Extract fund data from this PDF",
          threadId: generateUUID(),
          messageId: generateUUID(),
        });
      }

      if (isCSV) {
        // For CSV files, send the process request first
        const response = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: body,
        });

        if (!response.ok) {
          let errorMessage = `Extraction failed: ${response.statusText}`;
          const responseClone = response.clone();
          try {
            const errorData = await response.json();
            if (errorData.detail) {
              errorMessage += ` - ${errorData.detail}`;
            }
          } catch {
            try {
              const errorText = await responseClone.text();
              if (errorText) {
                errorMessage += ` - ${errorText}`;
              }
            } catch {
              // If both JSON and text parsing fail, use statusText only
            }
          }
          throw new Error(errorMessage);
        }

        // Get the session ID for streaming
        const sessionId = filePath ? csvSessionId : csvSessionIds[pathToProcess];
        
        // Now connect to the enhanced streaming endpoint for CSV
        const streamResponse = await fetch(`/api/onboarding/enhanced-stream/${sessionId}`);
        
        if (!streamResponse.ok) {
          throw new Error(`Failed to connect to stream: ${streamResponse.statusText}`);
        }

        const reader = streamResponse.body?.getReader();
        if (!reader) {
          throw new Error("No response stream available");
        }

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = new TextDecoder().decode(value);
          const lines = chunk.split("\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              try {
                const eventData = JSON.parse(line.slice(6));
                
                // Handle enhanced streaming events
                if (eventData.type === "connected") {
                  setExtractionLogs(prev => [...prev, "üì° Connected to processing stream"]);
                } else if (eventData.type === "chat_response") {
                  setExtractionLogs(prev => [...prev, `ü§ñ ${eventData.data.message}`]);
                } else if (eventData.type === "status_update") {
                  setExtractionStage(eventData.data.stage || eventData.data.status || "");
                  setExtractionLogs(prev => [...prev, `üìä ${eventData.data.status}: ${eventData.data.stage || 'processing'}`]);
                } else if (eventData.type === "data_processed") {
                  const portfolioData = eventData.data.portfolio_items || [];
                  setExtractionLogs(prev => [...prev, `‚úÖ Processed ${portfolioData.length} portfolio items`]);
                  
                  // Convert portfolio items to fund data format
                  const fundData = portfolioData.map((item: any) => ({
                    fund_name: item.name,
                    ticker: item.ticker,
                    asset_class: item.asset_class,
                    expense_ratio: item.expense_ratio,
                    morningstar_category: item.morningstar_category,
                    allocations: {
                      conservative: item.conservative_pct,
                      mod_conservative: item.mod_conservative_pct,
                      moderate: item.moderate_pct,
                      growth: item.growth_pct,
                      aggressive: item.aggressive_pct
                    }
                  }));
                  
                  setFundData(fundData);
                  setExtractionStatus("completed");
                } else if (eventData.type === "error") {
                  setExtractionStatus("error");
                  setExtractionLogs(prev => [...prev, `‚ùå Error: ${eventData.data.error}`]);
                } else if (eventData.type === "results") {
                  // Handle any final results
                  handleStreamEvent(eventData as ExtractEvent);
                } else {
                  // Log other events
                  const logMessage = JSON.stringify(eventData);
                  setExtractionLogs(prev => [...prev, logMessage]);
                }
              } catch (e) {
                console.error("Failed to parse event:", e);
              }
            }
          }
        }
        
      } else {
        // For PDF files, use the existing streaming response
        const response = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: body,
        });

        if (!response.ok) {
          let errorMessage = `Extraction failed: ${response.statusText}`;
          const responseClone = response.clone();
          try {
            const errorData = await response.json();
            if (errorData.detail) {
              errorMessage += ` - ${errorData.detail}`;
            }
          } catch {
            try {
              const errorText = await responseClone.text();
              if (errorText) {
                errorMessage += ` - ${errorText}`;
              }
            } catch {
              // If both JSON and text parsing fail, use statusText only
            }
          }
          throw new Error(errorMessage);
        }

        const reader = response.body?.getReader();
        if (!reader) {
          throw new Error("No response stream available");
        }

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = new TextDecoder().decode(value);
          const lines = chunk.split("\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              try {
                const eventData = JSON.parse(line.slice(6)) as ExtractEvent;
                handleStreamEvent(eventData);
              } catch (e) {
                console.error("Failed to parse event:", e);
              }
            }
          }
        }
      }

    } catch (error) {
      console.error("Extraction error:", error);
      setExtractionStatus("error");
      setExtractionLogs(prev => [...prev, `‚ùå Extraction failed: ${error}`]);
    } finally {
      setIsExtracting(false);
    }
  }, [filePath, filePaths]);

  // Handle streaming events
  const handleStreamEvent = useCallback((event: ExtractEvent) => {
    switch (event.type) {
      case "text":
        const content = event.data.content || "";
        setExtractionLogs(prev => [...prev, content]);
        break;

      case "status":
        setExtractionStage(event.data.stage || "");
        setExtractionProgress(event.data.progress || 0);
        if (event.data.message) {
          setExtractionLogs(prev => [...prev, `üìä ${event.data.message}`]);
        }
        break;

      case "fund_discovered":
        setExtractionLogs(prev => [
          ...prev,
          `üîç Found fund: ${event.data.fund_name} (${event.data.page_count} pages)`
        ]);
        break;

      case "fund_extracted":
        const fundData = event.data.fund as FundData;
        setExtractionLogs(prev => [
          ...prev,
          `üìã Extracted: ${fundData.fund_name}`
        ]);
        break;

      case "results":
        const funds = event.data.funds || [];
        setFundData(funds);
        setExtractionStatus("completed");
        setExtractionLogs(prev => [
          ...prev,
          `‚úÖ Extraction completed! Found ${funds.length} funds`
        ]);
        break;

      case "error":
        setExtractionStatus("error");
        setExtractionLogs(prev => [...prev, `‚ùå ${event.data.message}`]);
        break;
    }
  }, []);

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900">
      {/* Header */}
      <div className="border-b border-gray-800 bg-black/20 backdrop-blur-sm">
        <div className="container mx-auto px-6 py-4">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-2xl font-bold text-white">
                üè¶ Fund Analysis Platform
              </h1>
              <p className="text-gray-400 mt-1">
                AI-powered extraction and analysis of fund data
              </p>
            </div>
            
            {/* Navigation */}
            <div className="flex space-x-4">
              <div className="flex items-center space-x-2 text-white bg-white/10 px-3 py-2 rounded-lg">
                <FileText className="h-4 w-4" />
                <span className="text-sm">Classic Mode</span>
              </div>
              
              <Link 
                href="/chat"
                className="flex items-center space-x-2 text-black bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 px-4 py-2 rounded-lg transition-all duration-200 shadow-lg hover:shadow-xl"
              >
                <MessageSquare className="h-4 w-4" />
                <span className="text-sm font-medium">Try Chat Mode</span>
                <ArrowRight className="h-4 w-4" />
              </Link>
            </div>
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="flex h-[calc(100vh-80px)]">
        {/* Left Panel - Upload & Config */}
        <div className="w-1/4 min-w-[300px] p-6 border-r border-gray-800">
          <UploadPanel
            onFileUpload={handleFileUpload}
            onStartExtraction={handleStartExtraction}
            uploadedFile={uploadedFile}
            uploadedFiles={uploadedFiles}
            extractionStatus={extractionStatus}
            isExtracting={isExtracting}
            canExtract={(!!filePath || filePaths.length > 0) && !isExtracting}
          />
        </div>

        {/* Center - Extraction Progress & Logs */}
        <div className="flex-1 p-6">
          <ExtractionCanvas
            status={extractionStatus}
            progress={extractionProgress}
            stage={extractionStage}
            logs={extractionLogs}
            fundData={fundData}
            isExtracting={isExtracting}
          />
        </div>

        {/* Right Panel - Results & Charts */}
        <div className="w-1/3 min-w-[400px] p-6 border-l border-gray-800 flex flex-col">
          {/* Tab Navigation */}
          <div className="flex space-x-1 mb-4 bg-gray-800/30 p-1 rounded-lg">
            <button
              onClick={() => setActiveTab("results")}
              className={`flex-1 py-2 px-4 rounded-md text-sm font-medium transition-all duration-200 ${
                activeTab === "results"
                  ? "bg-blue-600 text-white"
                  : "text-gray-400 hover:text-white hover:bg-gray-700"
              }`}
            >
              üìä Results
            </button>
            <button
              onClick={() => setActiveTab("charts")}
              className={`flex-1 py-2 px-4 rounded-md text-sm font-medium transition-all duration-200 ${
                activeTab === "charts"
                  ? "bg-blue-600 text-white"
                  : "text-gray-400 hover:text-white hover:bg-gray-700"
              }`}
            >
              üìà Charts
            </button>
          </div>

          {/* Tab Content */}
          <div className="flex-1 overflow-hidden">
            {activeTab === "results" ? (
              <ResultsPanel
                funds={fundData}
                selectedFund={selectedFund}
                onSelectFund={setSelectedFund}
                extractionStatus={extractionStatus}
              />
            ) : (
              <div className="h-full overflow-y-auto">
                <Charts funds={fundData} />
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
